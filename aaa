import unittest
from unittest.mock import patch, MagicMock
from dao.execution_dao import ExecutionDAO
from models.execution import Execution

class TestExecutionDAO(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.env = {'db_url': 'mock_db_url'}

        # Patch the DB2Connector class
        cls.db_connector_patcher = patch('dao.execution_dao.DB2Connector')
        cls.mock_db_connector = cls.db_connector_patcher.start()

        # Create a MagicMock for the DB2Connector instance
        cls.mock_db_connector_instance = cls.mock_db_connector.return_value
        cls.mock_session = MagicMock()
        cls.mock_db_connector_instance.get_session.return_value = cls.mock_session

        # Instantiate the ExecutionDAO with the mocked DB2Connector and env
        cls.dao = ExecutionDAO(env=cls.env)

    @classmethod
    def tearDownClass(cls):
        cls.db_connector_patcher.stop()

    def setUp(self):
        # Reset mock session for each test
        self.mock_session.reset_mock()

    def tearDown(self):
        # Optionally perform cleanup after each test
        pass

    @classmethod
    def setUpTestData(cls):
        # Set up mock data once for all tests
        cls.mock_executions = [
            Execution(id=1, exec_name="Test Execution 1", mandate_id=1, asset_class_id=1,
                      start_ts='2023-05-26 00:00:00', end_ts='2023-05-26 01:00:00', status='Completed'),
            Execution(id=2, exec_name="Test Execution 2", mandate_id=2, asset_class_id=2,
                      start_ts='2023-05-27 00:00:00', end_ts='2023-05-27 01:00:00', status='Failed')
        ]

        cls.mock_session.query.return_value.all.return_value = cls.mock_executions

    def test_save_execution(self):
        execution = Execution(exec_name="Test Execution", mandate_id=1, asset_class_id=1,
                              start_ts='2023-05-26 00:00:00', end_ts='2023-05-26 01:00:00', status='Completed')

        self.dao.save_execution(execution)

        # Verify that the execution was added to the session and committed
        self.dao.session.add.assert_called_once_with(execution)
        self.dao.session.commit.assert_called_once()

    def test_get_all_executions(self):
        executions = self.dao.get_all_executions()

        self.assertEqual(len(executions), 2)
        self.assertEqual(executions[0].exec_name, "Test Execution 1")
        self.assertEqual(executions[1].exec_name, "Test Execution 2")

    def test_get_execution_by_id(self):
        execution_id = 1
        self.mock_session.query.return_value.filter_by.return_value.first.return_value = self.mock_executions[0]

        execution = self.dao.get_execution_by_id(execution_id)

        self.dao.session.query.assert_called_once_with(Execution)
        self.dao.session.query.return_value.filter_by.assert_called_once_with(id=execution_id)
        self.dao.session.query.return_value.filter_by.return_value.first.assert_called_once()
        self.assertEqual(execution.id, execution_id)
        self.assertEqual(execution.exec_name, "Test Execution 1")

    def test_get_execution_by_name(self):
        exec_name = "Test Execution 2"
        self.mock_session.query.return_value.filter_by.return_value.first.return_value = self.mock_executions[1]

        execution = self.dao.get_execution_by_name(exec_name)

        self.dao.session.query.assert_called_once_with(Execution)
        self.dao.session.query.return_value.filter_by.assert_called_once_with(exec_name=exec_name)
        self.dao.session.query.return_value.filter_by.return_value.first.assert_called_once()
        self.assertEqual(execution.exec_name, exec_name)
        self.assertEqual(execution.id, 2)

if __name__ == '__main__':
    unittest.main()
