import unittest
from unittest.mock import patch
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, scoped_session
from models import Execution, Base  # Assuming Execution and Base are defined in models.py
from execution_dao import ExecutionDAO  # Assuming ExecutionDAO is defined in execution_dao.py

# Define a temporary SQLite database in memory for testing
TEST_DATABASE_URL = 'sqlite:///:memory:'

class TestExecutionDAO(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Setup in-memory SQLite database
        cls.engine = create_engine(TEST_DATABASE_URL, echo=False)
        Base.metadata.create_all(cls.engine)
        cls.Session = scoped_session(sessionmaker(bind=cls.engine))

    def setUp(self):
        # Patch the ExecutionDAO to use the in-memory SQLite database
        patcher = patch('execution_dao.create_engine', return_value=self.engine)
        self.addCleanup(patcher.stop)
        self.mock_create_engine = patcher.start()

        # Create an instance of ExecutionDAO
        self.dao = ExecutionDAO()
        self.dao.Session = self.Session
        self.dao.session = self.Session()

    def tearDown(self):
        self.dao.session.rollback()
        self.dao.session.close()

    def test_save_execution(self):
        execution = Execution(name="Test Execution")
        self.dao.save(execution)

        # Verify execution was saved
        saved_execution = self.dao.session.query(Execution).filter_by(name="Test Execution").first()
        self.assertIsNotNone(saved_execution)
        self.assertEqual(saved_execution.name, "Test Execution")

    def test_get_all_executions(self):
        # Insert test data
        executions = [
            Execution(name="Execution 1"),
            Execution(name="Execution 2"),
            Execution(name="Execution 3")
        ]
        for execution in executions:
            self.dao.save(execution)

        # Retrieve all executions
        all_executions = self.dao.get_all_executions()

        # Verify all executions were retrieved
        self.assertEqual(len(all_executions), 3)
        self.assertEqual(all_executions[0].name, "Execution 1")
        self.assertEqual(all_executions[1].name, "Execution 2")
        self.assertEqual(all_executions[2].name, "Execution 3")

    def test_delete_execution(self):
        execution = Execution(name="Execution to delete")
        self.dao.save(execution)

        # Delete the execution
        self.dao.delete(execution.id)

        # Verify execution was deleted
        deleted_execution = self.dao.session.query(Execution).get(execution.id)
        self.assertIsNone(deleted_execution)

    def test_delete_non_existent_execution(self):
        # Attempt to delete a non-existent execution
        with self.assertRaises
