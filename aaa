from google.protobuf import descriptor_pb2
from google.protobuf import message_factory
from google.protobuf import descriptor_pool
from google.protobuf.message import Message
from typing import Any, Dict, List, Optional
import struct

class DynamicGpbHandler:
    def __init__(self):
        self.pool = descriptor_pool.Default()
        self.message_factory = message_factory.MessageFactory()
        
    def _try_get_message_type(self, binary_data: bytes) -> Optional[Message]:
        """
        Attempt to determine message type from binary data.
        This is a heuristic approach as .gpb files don't store the message type name.
        """
        try:
            # Try to get the first field tag and wire type
            tag_bytes = binary_data[:1]
            if not tag_bytes:
                return None
                
            # Get the field number and wire type
            tag = struct.unpack('B', tag_bytes)[0]
            field_number = tag >> 3
            
            # Look through the pool for matching descriptors
            for message_name in self.pool.FindFileByName('descriptor.proto').message_types_by_name:
                try:
                    message_descriptor = self.pool.FindMessageTypeByName(message_name)
                    if field_number in message_descriptor.fields_by_number:
                        return self.message_factory.GetPrototype(message_descriptor)
                except Exception:
                    continue
                    
        except Exception as e:
            print(f"Error in type detection: {str(e)}")
        return None

    def read_gpb_file(self, file_path: str) -> Optional[Message]:
        """
        Read a .gpb file and attempt to parse it dynamically.
        
        Args:
            file_path: Path to the .gpb file
            
        Returns:
            Parsed protobuf message or None if parsing fails
        """
        try:
            # Read the binary data
            with open(file_path, 'rb') as f:
                binary_data = f.read()
            
            print(f"Read {len(binary_data)} bytes from {file_path}")
            
            # Try to determine message type
            message_type = self._try_get_message_type(binary_data)
            if not message_type:
                raise ValueError("Could not determine message type from binary data")
            
            # Parse the message
            message = message_type()
            message.ParseFromString(binary_data)
            return message
            
        except Exception as e:
            print(f"Error reading GPB file: {str(e)}")
            return None

    def print_message_content(self, message: Message, indent: int = 0):
        """
        Print the content of a protobuf message recursively.
        
        Args:
            message: Protobuf message to print
            indent: Indentation level
        """
        for field_descriptor, value in message.ListFields():
            prefix = '  ' * indent
            if field_descriptor.type == descriptor_pb2.FieldDescriptor.TYPE_MESSAGE:
                print(f"{prefix}{field_descriptor.name}: {{")
                if field_descriptor.label == descriptor_pb2.FieldDescriptor.LABEL_REPEATED:
                    for item in value:
                        self.print_message_content(item, indent + 1)
                else:
                    self.print_message_content(value, indent + 1)
                print(f"{prefix}}}")
            else:
                if field_descriptor.label == descriptor_pb2.FieldDescriptor.LABEL_REPEATED:
                    print(f"{prefix}{field_descriptor.name}: {list(value)}")
                else:
                    print(f"{prefix}{field_descriptor.name}: {value}")

    def update_field_value(self, message: Message, path: str, new_value: Any) -> bool:
        """
        Update a field value in the message using a path.
        
        Args:
            message: The protobuf message to update
            path: Dot-separated path to the field
            new_value: New value to set
            
        Returns:
            bool: True if update was successful
        """
        try:
            current = message
            path_parts = path.split('.')
            
            # Navigate to the final container
            for i, part in enumerate(path_parts[:-1]):
                if '[' in part and ']' in part:
                    field_name, index_str = part.split('[')
                    index = int(index_str.rstrip(']'))
                    current = getattr(current, field_name)[index]
                else:
                    current = getattr(current, part)
            
            # Set the final field
            last_part = path_parts[-1]
            if '[' in last_part and ']' in last_part:
                field_name, index_str = last_part.split('[')
                index = int(index_str.rstrip(']'))
                repeated_field = getattr(current, field_name)
                repeated_field[index] = new_value
            else:
                setattr(current, last_part, new_value)
            
            return True
            
        except Exception as e:
            print(f"Error updating field at path {path}: {str(e)}")
            return False

    def save_gpb_file(self, message: Message, file_path: str) -> bool:
        """
        Save the updated message back to a .gpb file.
        
        Args:
            message: The protobuf message to save
            file_path: Path where to save the file
            
        Returns:
            bool: True if save was successful
        """
        try:
            with open(file_path, 'wb') as f:
                f.write(message.SerializeToString())
            return True
        except Exception as e:
            print(f"Error saving GPB file: {str(e)}")
            return False

# Example usage
def main():
    # Create handler
    handler = DynamicGpbHandler()
    
    # Read the .gpb file
    gpb_file_path = "your_file.gpb"  # Replace with your .gpb file path
    message = handler.read_gpb_file(gpb_file_path)
    
    if message:
        print("\nOriginal message content:")
        handler.print_message_content(message)
        
        # Example updates
        updates = [
            {"path": "field1", "value": "new_value"},
            {"path": "nested.field", "value": 42},
            {"path": "repeated_field[0]", "value": "updated"}
        ]
        
        # Apply updates
        for update in updates:
            success = handler.update_field_value(message, update["path"], update["value"])
            print(f"\nUpdate {update['path']}: {'Success' if success else 'Failed'}")
        
        # Save updated message
        output_file = "updated_file.gpb"
        if handler.save_gpb_file(message, output_file):
            print(f"\nSaved updated message to {output_file}")
            
            # Print updated content
            print("\nUpdated message content:")
            updated_message = handler.read_gpb_file(output_file)
            if updated_message:
                handler.print_message_content(updated_message)
    else:
        print("Failed to read GPB file")

if __name__ == "__main__":
    main()

# Create the handler
handler = DynamicGpbHandler()

# Read your .gpb file
gpb_file = "path/to/your/file.gpb"
message = handler.read_gpb_file(gpb_file)

# Print the current content to see the structure
if message:
    print("Message content:")
    handler.print_message_content(message)
    
    # Define your updates
    updates = [
        {"path": "some_field", "value": "new_value"},
        {"path": "nested.field", "value": 42}
    ]
    
    # Apply updates
    for update in updates:
        handler.update_field_value(message, update["path"], update["value"])
    
    # Save the updated message
    handler.save_gpb_file(message, "updated_file.gpb")
