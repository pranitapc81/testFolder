import unittest
from unittest.mock import patch, MagicMock
from sqlalchemy.orm import sessionmaker, scoped_session
from unified_alchemy_magic_mock import AlchemyMagicMock
from models import Execution, Base
from execution_dao import ExecutionDAO  # Adjust according to your project structure
from db2_connector import DB2Connector  # Adjust according to your project structure

class TestExecutionDAO(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Setup in-memory SQLite database
        cls.engine = AlchemyMagicMock()
        Base.metadata.create_all(cls.engine)
        cls.Session = scoped_session(sessionmaker(bind=cls.engine))

    def setUp(self):
        # Mock DB2Connector to return the in-memory SQLite session
        self.mock_connector = MagicMock(spec=DB2Connector)
        self.mock_connector.get_session.return_value = self.Session()

        # Create an instance of ExecutionDAO with the mocked connector
        self.dao = ExecutionDAO(self.mock_connector)

    def tearDown(self):
        self.dao.session.rollback()
        self.dao.session.close()

    def test_save_execution(self):
        execution = Execution(name="Test Execution")
        self.dao.save(execution)

        # Verify execution was saved
        saved_execution = self.dao.session.query(Execution).filter_by(name="Test Execution").first()
        self.assertIsNotNone(saved_execution)
        self.assertEqual(saved_execution.name, "Test Execution")

    def test_get_all_executions(self):
        # Insert test data
        executions = [
            Execution(name="Execution 1"),
            Execution(name="Execution 2"),
            Execution(name="Execution 3")
        ]
        for execution in executions:
            self.dao.save(execution)

        # Retrieve all executions
        all_executions = self.dao.get_all_executions()

        # Verify all executions were retrieved
        self.assertEqual(len(all_executions), 3)
        self.assertEqual(all_executions[0].name, "Execution 1")
        self.assertEqual(all_executions[1].name, "Execution 2")
        self.assertEqual(all_executions[2].name, "Execution 3")

    def test_delete_execution(self):
        execution = Execution(name="Execution to delete")
        self.dao.save(execution)

        # Delete the execution
        self.dao.delete(execution.id)

        # Verify execution was deleted
        deleted_execution = self.dao.session.query(Execution).get(execution.id)
        self.assertIsNone(deleted_execution)

    def test_delete_non_existent_execution(self):
        # Attempt to delete a non-existent execution
        with self.assertRaises(Exception):
            self.dao.delete(-1)  # Assuming execution with id=-1 doesn't exist

if __name__ == '__main__':
    unittest.main()
