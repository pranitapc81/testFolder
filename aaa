import unittest
from sqlalchemy import create_engine, Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
from execution_dao import ExecutionDAO, Execution  # Assuming Execution and ExecutionDAO are defined in execution_dao module

Base = declarative_base()

# Define a temporary SQLite database in memory for testing
TEST_DATABASE_URL = 'sqlite:///:memory:'

# SQLAlchemy model definition for Execution
class Execution(Base):
    __tablename__ = 'executions'

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.now)

# Setup function to create database schema and session for testing
def setup_module():
    engine = create_engine(TEST_DATABASE_URL, echo=True)
    Base.metadata.create_all(engine)
    Session = sessionmaker(bind=engine)
    session = Session()

    # Inject session into ExecutionDAO for testing
    global dao
    dao = ExecutionDAO(session)

# Unit test class for ExecutionDAO
class TestExecutionDAO(unittest.TestCase):
    def test_save_execution(self):
        execution = Execution(name="Test Execution")
        dao.save(execution)

        # Verify execution was saved
        saved_execution = dao.session.query(Execution).filter_by(name="Test Execution").first()
        self.assertIsNotNone(saved_execution)
        self.assertEqual(saved_execution.name, "Test Execution")

    def test_get_all_executions(self):
        # Insert test data
        executions = [
            Execution(name="Execution 1"),
            Execution(name="Execution 2"),
            Execution(name="Execution 3")
        ]
        for execution in executions:
            dao.save(execution)

        # Retrieve all executions
        all_executions = dao.get_all_executions()

        # Verify all executions were retrieved
        self.assertEqual(len(all_executions), 3)
        self.assertEqual(all_executions[0].name, "Execution 1")
        self.assertEqual(all_executions[1].name, "Execution 2")
        self.assertEqual(all_executions[2].name, "Execution 3")

    def test_delete_execution(self):
        execution = Execution(name="Execution to delete")
        dao.save(execution)

        # Delete the execution
        dao.delete(execution.id)

        # Verify execution was deleted
        deleted_execution = dao.session.query(Execution).get(execution.id)
        self.assertIsNone(deleted_execution)

    def test_error_handling(self):
        # Attempt to delete a non-existent execution
        with self.assertRaises(Exception):
            dao.delete(-1)  # Assuming execution with id=-1 doesn't exist

if __name__ == '__main__':
    unittest.main()

